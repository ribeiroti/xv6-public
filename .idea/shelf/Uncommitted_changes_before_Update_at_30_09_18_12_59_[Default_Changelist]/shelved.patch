Index: lottery.asm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n_lottery: formato do arquivo elf32-i386\n\n\nDesmontagem da seção .text:\n\n00000000 <main>:\n\n\nvoid process_test(int tickets);\n\n\nint main() {\n   0:\t8d 4c 24 04          \tlea    0x4(%esp),%ecx\n   4:\t83 e4 f0             \tand    $0xfffffff0,%esp\n   7:\tff 71 fc             \tpushl  -0x4(%ecx)\n   a:\t55                   \tpush   %ebp\n   b:\t89 e5                \tmov    %esp,%ebp\n   d:\t53                   \tpush   %ebx\n\n\n    for (int i = 1; i <= QTD_PROC; i++) {\n   e:\tbb 01 00 00 00       \tmov    $0x1,%ebx\nint main() {\n  13:\t51                   \tpush   %ecx\n  14:\teb 12                \tjmp    28 <main+0x28>\n  16:\t8d 76 00             \tlea    0x0(%esi),%esi\n  19:\t8d bc 27 00 00 00 00 \tlea    0x0(%edi,%eiz,1),%edi\n    for (int i = 1; i <= QTD_PROC; i++) {\n  20:\t83 c3 01             \tadd    $0x1,%ebx\n  23:\t83 fb 0b             \tcmp    $0xb,%ebx\n  26:\t74 20                \tje     48 <main+0x48>\n        process_test(i*i*100);\n  28:\t89 d8                \tmov    %ebx,%eax\n\nvoid process_test(int tickets){\n\n    int i = 0;\n\n    if (fork(tickets)) {\n  2a:\t83 ec 0c             \tsub    $0xc,%esp\n        process_test(i*i*100);\n  2d:\t0f af c3             \timul   %ebx,%eax\n  30:\t6b c0 64             \timul   $0x64,%eax,%eax\n    if (fork(tickets)) {\n  33:\t50                   \tpush   %eax\n  34:\te8 a1 02 00 00       \tcall   2da <fork>\n  39:\t83 c4 10             \tadd    $0x10,%esp\n  3c:\t85 c0                \ttest   %eax,%eax\n  3e:\t74 e0                \tje     20 <main+0x20>\n  40:\teb fe                \tjmp    40 <main+0x40>\n  42:\t8d b6 00 00 00 00    \tlea    0x0(%esi),%esi\n  48:\t83 ec 0c             \tsub    $0xc,%esp\n  4b:\t6a 01                \tpush   $0x1\n  4d:\te8 88 02 00 00       \tcall   2da <fork>\n  52:\t83 c4 10             \tadd    $0x10,%esp\n  55:\t85 c0                \ttest   %eax,%eax\n  57:\t74 02                \tje     5b <main+0x5b>\n  59:\teb fe                \tjmp    59 <main+0x59>\n    exit();\n  5b:\te8 82 02 00 00       \tcall   2e2 <exit>\n\n00000060 <process_test>:\nvoid process_test(int tickets){\n  60:\t55                   \tpush   %ebp\n  61:\t89 e5                \tmov    %esp,%ebp\n  63:\t83 ec 14             \tsub    $0x14,%esp\n    if (fork(tickets)) {\n  66:\tff 75 08             \tpushl  0x8(%ebp)\n  69:\te8 6c 02 00 00       \tcall   2da <fork>\n  6e:\t83 c4 10             \tadd    $0x10,%esp\n  71:\t85 c0                \ttest   %eax,%eax\n  73:\t74 0b                \tje     80 <process_test+0x20>\n  75:\teb fe                \tjmp    75 <process_test+0x15>\n  77:\t89 f6                \tmov    %esi,%esi\n  79:\t8d bc 27 00 00 00 00 \tlea    0x0(%edi,%eiz,1),%edi\n\n        // LOOP INFINITO INCREMENTANDO VARIÁVEL PARA NÃO OTIMIZAR\n        while (1) i++;\n\n    }\n}\n  80:\tc9                   \tleave  \n  81:\tc3                   \tret    \n  82:\t66 90                \txchg   %ax,%ax\n  84:\t66 90                \txchg   %ax,%ax\n  86:\t66 90                \txchg   %ax,%ax\n  88:\t66 90                \txchg   %ax,%ax\n  8a:\t66 90                \txchg   %ax,%ax\n  8c:\t66 90                \txchg   %ax,%ax\n  8e:\t66 90                \txchg   %ax,%ax\n\n00000090 <strcpy>:\n#include \"user.h\"\n#include \"x86.h\"\n\nchar*\nstrcpy(char *s, const char *t)\n{\n  90:\t55                   \tpush   %ebp\n  91:\t89 e5                \tmov    %esp,%ebp\n  93:\t53                   \tpush   %ebx\n  94:\t8b 45 08             \tmov    0x8(%ebp),%eax\n  97:\t8b 4d 0c             \tmov    0xc(%ebp),%ecx\n  char *os;\n\n  os = s;\n  while((*s++ = *t++) != 0)\n  9a:\t89 c2                \tmov    %eax,%edx\n  9c:\t8d 74 26 00          \tlea    0x0(%esi,%eiz,1),%esi\n  a0:\t83 c1 01             \tadd    $0x1,%ecx\n  a3:\t0f b6 59 ff          \tmovzbl -0x1(%ecx),%ebx\n  a7:\t83 c2 01             \tadd    $0x1,%edx\n  aa:\t84 db                \ttest   %bl,%bl\n  ac:\t88 5a ff             \tmov    %bl,-0x1(%edx)\n  af:\t75 ef                \tjne    a0 <strcpy+0x10>\n    ;\n  return os;\n}\n  b1:\t5b                   \tpop    %ebx\n  b2:\t5d                   \tpop    %ebp\n  b3:\tc3                   \tret    \n  b4:\t8d b6 00 00 00 00    \tlea    0x0(%esi),%esi\n  ba:\t8d bf 00 00 00 00    \tlea    0x0(%edi),%edi\n\n000000c0 <strcmp>:\n\nint\nstrcmp(const char *p, const char *q)\n{\n  c0:\t55                   \tpush   %ebp\n  c1:\t89 e5                \tmov    %esp,%ebp\n  c3:\t53                   \tpush   %ebx\n  c4:\t8b 55 08             \tmov    0x8(%ebp),%edx\n  c7:\t8b 4d 0c             \tmov    0xc(%ebp),%ecx\n  while(*p && *p == *q)\n  ca:\t0f b6 02             \tmovzbl (%edx),%eax\n  cd:\t0f b6 19             \tmovzbl (%ecx),%ebx\n  d0:\t84 c0                \ttest   %al,%al\n  d2:\t75 1c                \tjne    f0 <strcmp+0x30>\n  d4:\teb 2a                \tjmp    100 <strcmp+0x40>\n  d6:\t8d 76 00             \tlea    0x0(%esi),%esi\n  d9:\t8d bc 27 00 00 00 00 \tlea    0x0(%edi,%eiz,1),%edi\n    p++, q++;\n  e0:\t83 c2 01             \tadd    $0x1,%edx\n  while(*p && *p == *q)\n  e3:\t0f b6 02             \tmovzbl (%edx),%eax\n    p++, q++;\n  e6:\t83 c1 01             \tadd    $0x1,%ecx\n  e9:\t0f b6 19             \tmovzbl (%ecx),%ebx\n  while(*p && *p == *q)\n  ec:\t84 c0                \ttest   %al,%al\n  ee:\t74 10                \tje     100 <strcmp+0x40>\n  f0:\t38 d8                \tcmp    %bl,%al\n  f2:\t74 ec                \tje     e0 <strcmp+0x20>\n  return (uchar)*p - (uchar)*q;\n  f4:\t29 d8                \tsub    %ebx,%eax\n}\n  f6:\t5b                   \tpop    %ebx\n  f7:\t5d                   \tpop    %ebp\n  f8:\tc3                   \tret    \n  f9:\t8d b4 26 00 00 00 00 \tlea    0x0(%esi,%eiz,1),%esi\n 100:\t31 c0                \txor    %eax,%eax\n  return (uchar)*p - (uchar)*q;\n 102:\t29 d8                \tsub    %ebx,%eax\n}\n 104:\t5b                   \tpop    %ebx\n 105:\t5d                   \tpop    %ebp\n 106:\tc3                   \tret    \n 107:\t89 f6                \tmov    %esi,%esi\n 109:\t8d bc 27 00 00 00 00 \tlea    0x0(%edi,%eiz,1),%edi\n\n00000110 <strlen>:\n\nuint\nstrlen(const char *s)\n{\n 110:\t55                   \tpush   %ebp\n 111:\t89 e5                \tmov    %esp,%ebp\n 113:\t8b 4d 08             \tmov    0x8(%ebp),%ecx\n  int n;\n\n  for(n = 0; s[n]; n++)\n 116:\t80 39 00             \tcmpb   $0x0,(%ecx)\n 119:\t74 15                \tje     130 <strlen+0x20>\n 11b:\t31 d2                \txor    %edx,%edx\n 11d:\t8d 76 00             \tlea    0x0(%esi),%esi\n 120:\t83 c2 01             \tadd    $0x1,%edx\n 123:\t80 3c 11 00          \tcmpb   $0x0,(%ecx,%edx,1)\n 127:\t89 d0                \tmov    %edx,%eax\n 129:\t75 f5                \tjne    120 <strlen+0x10>\n    ;\n  return n;\n}\n 12b:\t5d                   \tpop    %ebp\n 12c:\tc3                   \tret    \n 12d:\t8d 76 00             \tlea    0x0(%esi),%esi\n  for(n = 0; s[n]; n++)\n 130:\t31 c0                \txor    %eax,%eax\n}\n 132:\t5d                   \tpop    %ebp\n 133:\tc3                   \tret    \n 134:\t8d b6 00 00 00 00    \tlea    0x0(%esi),%esi\n 13a:\t8d bf 00 00 00 00    \tlea    0x0(%edi),%edi\n\n00000140 <memset>:\n\nvoid*\nmemset(void *dst, int c, uint n)\n{\n 140:\t55                   \tpush   %ebp\n 141:\t89 e5                \tmov    %esp,%ebp\n 143:\t57                   \tpush   %edi\n 144:\t8b 55 08             \tmov    0x8(%ebp),%edx\n}\n\nstatic inline void\nstosb(void *addr, int data, int cnt)\n{\n  asm volatile(\"cld; rep stosb\" :\n 147:\t8b 4d 10             \tmov    0x10(%ebp),%ecx\n 14a:\t8b 45 0c             \tmov    0xc(%ebp),%eax\n 14d:\t89 d7                \tmov    %edx,%edi\n 14f:\tfc                   \tcld    \n 150:\tf3 aa                \trep stos %al,%es:(%edi)\n  stosb(dst, c, n);\n  return dst;\n}\n 152:\t89 d0                \tmov    %edx,%eax\n 154:\t5f                   \tpop    %edi\n 155:\t5d                   \tpop    %ebp\n 156:\tc3                   \tret    \n 157:\t89 f6                \tmov    %esi,%esi\n 159:\t8d bc 27 00 00 00 00 \tlea    0x0(%edi,%eiz,1),%edi\n\n00000160 <strchr>:\n\nchar*\nstrchr(const char *s, char c)\n{\n 160:\t55                   \tpush   %ebp\n 161:\t89 e5                \tmov    %esp,%ebp\n 163:\t53                   \tpush   %ebx\n 164:\t8b 45 08             \tmov    0x8(%ebp),%eax\n 167:\t8b 5d 0c             \tmov    0xc(%ebp),%ebx\n  for(; *s; s++)\n 16a:\t0f b6 10             \tmovzbl (%eax),%edx\n 16d:\t84 d2                \ttest   %dl,%dl\n 16f:\t74 1d                \tje     18e <strchr+0x2e>\n    if(*s == c)\n 171:\t38 d3                \tcmp    %dl,%bl\n 173:\t89 d9                \tmov    %ebx,%ecx\n 175:\t75 0d                \tjne    184 <strchr+0x24>\n 177:\teb 17                \tjmp    190 <strchr+0x30>\n 179:\t8d b4 26 00 00 00 00 \tlea    0x0(%esi,%eiz,1),%esi\n 180:\t38 ca                \tcmp    %cl,%dl\n 182:\t74 0c                \tje     190 <strchr+0x30>\n  for(; *s; s++)\n 184:\t83 c0 01             \tadd    $0x1,%eax\n 187:\t0f b6 10             \tmovzbl (%eax),%edx\n 18a:\t84 d2                \ttest   %dl,%dl\n 18c:\t75 f2                \tjne    180 <strchr+0x20>\n      return (char*)s;\n  return 0;\n 18e:\t31 c0                \txor    %eax,%eax\n}\n 190:\t5b                   \tpop    %ebx\n 191:\t5d                   \tpop    %ebp\n 192:\tc3                   \tret    \n 193:\t8d b6 00 00 00 00    \tlea    0x0(%esi),%esi\n 199:\t8d bc 27 00 00 00 00 \tlea    0x0(%edi,%eiz,1),%edi\n\n000001a0 <gets>:\n\nchar*\ngets(char *buf, int max)\n{\n 1a0:\t55                   \tpush   %ebp\n 1a1:\t89 e5                \tmov    %esp,%ebp\n 1a3:\t57                   \tpush   %edi\n 1a4:\t56                   \tpush   %esi\n 1a5:\t53                   \tpush   %ebx\n  int i, cc;\n  char c;\n\n  for(i=0; i+1 < max; ){\n 1a6:\t31 f6                \txor    %esi,%esi\n 1a8:\t89 f3                \tmov    %esi,%ebx\n{\n 1aa:\t83 ec 1c             \tsub    $0x1c,%esp\n 1ad:\t8b 7d 08             \tmov    0x8(%ebp),%edi\n  for(i=0; i+1 < max; ){\n 1b0:\teb 2f                \tjmp    1e1 <gets+0x41>\n 1b2:\t8d b6 00 00 00 00    \tlea    0x0(%esi),%esi\n    cc = read(0, &c, 1);\n 1b8:\t8d 45 e7             \tlea    -0x19(%ebp),%eax\n 1bb:\t83 ec 04             \tsub    $0x4,%esp\n 1be:\t6a 01                \tpush   $0x1\n 1c0:\t50                   \tpush   %eax\n 1c1:\t6a 00                \tpush   $0x0\n 1c3:\te8 32 01 00 00       \tcall   2fa <read>\n    if(cc < 1)\n 1c8:\t83 c4 10             \tadd    $0x10,%esp\n 1cb:\t85 c0                \ttest   %eax,%eax\n 1cd:\t7e 1c                \tjle    1eb <gets+0x4b>\n      break;\n    buf[i++] = c;\n 1cf:\t0f b6 45 e7          \tmovzbl -0x19(%ebp),%eax\n 1d3:\t83 c7 01             \tadd    $0x1,%edi\n 1d6:\t88 47 ff             \tmov    %al,-0x1(%edi)\n    if(c == '\\n' || c == '\\r')\n 1d9:\t3c 0a                \tcmp    $0xa,%al\n 1db:\t74 23                \tje     200 <gets+0x60>\n 1dd:\t3c 0d                \tcmp    $0xd,%al\n 1df:\t74 1f                \tje     200 <gets+0x60>\n  for(i=0; i+1 < max; ){\n 1e1:\t83 c3 01             \tadd    $0x1,%ebx\n 1e4:\t3b 5d 0c             \tcmp    0xc(%ebp),%ebx\n 1e7:\t89 fe                \tmov    %edi,%esi\n 1e9:\t7c cd                \tjl     1b8 <gets+0x18>\n 1eb:\t89 f3                \tmov    %esi,%ebx\n      break;\n  }\n  buf[i] = '\\0';\n  return buf;\n}\n 1ed:\t8b 45 08             \tmov    0x8(%ebp),%eax\n  buf[i] = '\\0';\n 1f0:\tc6 03 00             \tmovb   $0x0,(%ebx)\n}\n 1f3:\t8d 65 f4             \tlea    -0xc(%ebp),%esp\n 1f6:\t5b                   \tpop    %ebx\n 1f7:\t5e                   \tpop    %esi\n 1f8:\t5f                   \tpop    %edi\n 1f9:\t5d                   \tpop    %ebp\n 1fa:\tc3                   \tret    \n 1fb:\t90                   \tnop\n 1fc:\t8d 74 26 00          \tlea    0x0(%esi,%eiz,1),%esi\n 200:\t8b 75 08             \tmov    0x8(%ebp),%esi\n 203:\t8b 45 08             \tmov    0x8(%ebp),%eax\n 206:\t01 de                \tadd    %ebx,%esi\n 208:\t89 f3                \tmov    %esi,%ebx\n  buf[i] = '\\0';\n 20a:\tc6 03 00             \tmovb   $0x0,(%ebx)\n}\n 20d:\t8d 65 f4             \tlea    -0xc(%ebp),%esp\n 210:\t5b                   \tpop    %ebx\n 211:\t5e                   \tpop    %esi\n 212:\t5f                   \tpop    %edi\n 213:\t5d                   \tpop    %ebp\n 214:\tc3                   \tret    \n 215:\t8d 74 26 00          \tlea    0x0(%esi,%eiz,1),%esi\n 219:\t8d bc 27 00 00 00 00 \tlea    0x0(%edi,%eiz,1),%edi\n\n00000220 <stat>:\n\nint\nstat(const char *n, struct stat *st)\n{\n 220:\t55                   \tpush   %ebp\n 221:\t89 e5                \tmov    %esp,%ebp\n 223:\t56                   \tpush   %esi\n 224:\t53                   \tpush   %ebx\n  int fd;\n  int r;\n\n  fd = open(n, O_RDONLY);\n 225:\t83 ec 08             \tsub    $0x8,%esp\n 228:\t6a 00                \tpush   $0x0\n 22a:\tff 75 08             \tpushl  0x8(%ebp)\n 22d:\te8 f0 00 00 00       \tcall   322 <open>\n  if(fd < 0)\n 232:\t83 c4 10             \tadd    $0x10,%esp\n 235:\t85 c0                \ttest   %eax,%eax\n 237:\t78 27                \tjs     260 <stat+0x40>\n    return -1;\n  r = fstat(fd, st);\n 239:\t83 ec 08             \tsub    $0x8,%esp\n 23c:\tff 75 0c             \tpushl  0xc(%ebp)\n 23f:\t89 c3                \tmov    %eax,%ebx\n 241:\t50                   \tpush   %eax\n 242:\te8 f3 00 00 00       \tcall   33a <fstat>\n  close(fd);\n 247:\t89 1c 24             \tmov    %ebx,(%esp)\n  r = fstat(fd, st);\n 24a:\t89 c6                \tmov    %eax,%esi\n  close(fd);\n 24c:\te8 b9 00 00 00       \tcall   30a <close>\n  return r;\n 251:\t83 c4 10             \tadd    $0x10,%esp\n}\n 254:\t8d 65 f8             \tlea    -0x8(%ebp),%esp\n 257:\t89 f0                \tmov    %esi,%eax\n 259:\t5b                   \tpop    %ebx\n 25a:\t5e                   \tpop    %esi\n 25b:\t5d                   \tpop    %ebp\n 25c:\tc3                   \tret    \n 25d:\t8d 76 00             \tlea    0x0(%esi),%esi\n    return -1;\n 260:\tbe ff ff ff ff       \tmov    $0xffffffff,%esi\n 265:\teb ed                \tjmp    254 <stat+0x34>\n 267:\t89 f6                \tmov    %esi,%esi\n 269:\t8d bc 27 00 00 00 00 \tlea    0x0(%edi,%eiz,1),%edi\n\n00000270 <atoi>:\n\nint\natoi(const char *s)\n{\n 270:\t55                   \tpush   %ebp\n 271:\t89 e5                \tmov    %esp,%ebp\n 273:\t53                   \tpush   %ebx\n 274:\t8b 4d 08             \tmov    0x8(%ebp),%ecx\n  int n;\n\n  n = 0;\n  while('0' <= *s && *s <= '9')\n 277:\t0f be 11             \tmovsbl (%ecx),%edx\n 27a:\t8d 42 d0             \tlea    -0x30(%edx),%eax\n 27d:\t3c 09                \tcmp    $0x9,%al\n  n = 0;\n 27f:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  while('0' <= *s && *s <= '9')\n 284:\t77 1f                \tja     2a5 <atoi+0x35>\n 286:\t8d 76 00             \tlea    0x0(%esi),%esi\n 289:\t8d bc 27 00 00 00 00 \tlea    0x0(%edi,%eiz,1),%edi\n    n = n*10 + *s++ - '0';\n 290:\t8d 04 80             \tlea    (%eax,%eax,4),%eax\n 293:\t83 c1 01             \tadd    $0x1,%ecx\n 296:\t8d 44 42 d0          \tlea    -0x30(%edx,%eax,2),%eax\n  while('0' <= *s && *s <= '9')\n 29a:\t0f be 11             \tmovsbl (%ecx),%edx\n 29d:\t8d 5a d0             \tlea    -0x30(%edx),%ebx\n 2a0:\t80 fb 09             \tcmp    $0x9,%bl\n 2a3:\t76 eb                \tjbe    290 <atoi+0x20>\n  return n;\n}\n 2a5:\t5b                   \tpop    %ebx\n 2a6:\t5d                   \tpop    %ebp\n 2a7:\tc3                   \tret    \n 2a8:\t90                   \tnop\n 2a9:\t8d b4 26 00 00 00 00 \tlea    0x0(%esi,%eiz,1),%esi\n\n000002b0 <memmove>:\n\nvoid*\nmemmove(void *vdst, const void *vsrc, int n)\n{\n 2b0:\t55                   \tpush   %ebp\n 2b1:\t89 e5                \tmov    %esp,%ebp\n 2b3:\t56                   \tpush   %esi\n 2b4:\t53                   \tpush   %ebx\n 2b5:\t8b 5d 10             \tmov    0x10(%ebp),%ebx\n 2b8:\t8b 45 08             \tmov    0x8(%ebp),%eax\n 2bb:\t8b 75 0c             \tmov    0xc(%ebp),%esi\n  char *dst;\n  const char *src;\n\n  dst = vdst;\n  src = vsrc;\n  while(n-- > 0)\n 2be:\t85 db                \ttest   %ebx,%ebx\n 2c0:\t7e 14                \tjle    2d6 <memmove+0x26>\n 2c2:\t31 d2                \txor    %edx,%edx\n 2c4:\t8d 74 26 00          \tlea    0x0(%esi,%eiz,1),%esi\n    *dst++ = *src++;\n 2c8:\t0f b6 0c 16          \tmovzbl (%esi,%edx,1),%ecx\n 2cc:\t88 0c 10             \tmov    %cl,(%eax,%edx,1)\n 2cf:\t83 c2 01             \tadd    $0x1,%edx\n  while(n-- > 0)\n 2d2:\t39 d3                \tcmp    %edx,%ebx\n 2d4:\t75 f2                \tjne    2c8 <memmove+0x18>\n  return vdst;\n}\n 2d6:\t5b                   \tpop    %ebx\n 2d7:\t5e                   \tpop    %esi\n 2d8:\t5d                   \tpop    %ebp\n 2d9:\tc3                   \tret    \n\n000002da <fork>:\n  name: \\\n    movl $SYS_ ## name, %eax; \\\n    int $T_SYSCALL; \\\n    ret\n\nSYSCALL(fork)\n 2da:\tb8 01 00 00 00       \tmov    $0x1,%eax\n 2df:\tcd 40                \tint    $0x40\n 2e1:\tc3                   \tret    \n\n000002e2 <exit>:\nSYSCALL(exit)\n 2e2:\tb8 02 00 00 00       \tmov    $0x2,%eax\n 2e7:\tcd 40                \tint    $0x40\n 2e9:\tc3                   \tret    \n\n000002ea <wait>:\nSYSCALL(wait)\n 2ea:\tb8 03 00 00 00       \tmov    $0x3,%eax\n 2ef:\tcd 40                \tint    $0x40\n 2f1:\tc3                   \tret    \n\n000002f2 <pipe>:\nSYSCALL(pipe)\n 2f2:\tb8 04 00 00 00       \tmov    $0x4,%eax\n 2f7:\tcd 40                \tint    $0x40\n 2f9:\tc3                   \tret    \n\n000002fa <read>:\nSYSCALL(read)\n 2fa:\tb8 05 00 00 00       \tmov    $0x5,%eax\n 2ff:\tcd 40                \tint    $0x40\n 301:\tc3                   \tret    \n\n00000302 <write>:\nSYSCALL(write)\n 302:\tb8 10 00 00 00       \tmov    $0x10,%eax\n 307:\tcd 40                \tint    $0x40\n 309:\tc3                   \tret    \n\n0000030a <close>:\nSYSCALL(close)\n 30a:\tb8 15 00 00 00       \tmov    $0x15,%eax\n 30f:\tcd 40                \tint    $0x40\n 311:\tc3                   \tret    \n\n00000312 <kill>:\nSYSCALL(kill)\n 312:\tb8 06 00 00 00       \tmov    $0x6,%eax\n 317:\tcd 40                \tint    $0x40\n 319:\tc3                   \tret    \n\n0000031a <exec>:\nSYSCALL(exec)\n 31a:\tb8 07 00 00 00       \tmov    $0x7,%eax\n 31f:\tcd 40                \tint    $0x40\n 321:\tc3                   \tret    \n\n00000322 <open>:\nSYSCALL(open)\n 322:\tb8 0f 00 00 00       \tmov    $0xf,%eax\n 327:\tcd 40                \tint    $0x40\n 329:\tc3                   \tret    \n\n0000032a <mknod>:\nSYSCALL(mknod)\n 32a:\tb8 11 00 00 00       \tmov    $0x11,%eax\n 32f:\tcd 40                \tint    $0x40\n 331:\tc3                   \tret    \n\n00000332 <unlink>:\nSYSCALL(unlink)\n 332:\tb8 12 00 00 00       \tmov    $0x12,%eax\n 337:\tcd 40                \tint    $0x40\n 339:\tc3                   \tret    \n\n0000033a <fstat>:\nSYSCALL(fstat)\n 33a:\tb8 08 00 00 00       \tmov    $0x8,%eax\n 33f:\tcd 40                \tint    $0x40\n 341:\tc3                   \tret    \n\n00000342 <link>:\nSYSCALL(link)\n 342:\tb8 13 00 00 00       \tmov    $0x13,%eax\n 347:\tcd 40                \tint    $0x40\n 349:\tc3                   \tret    \n\n0000034a <mkdir>:\nSYSCALL(mkdir)\n 34a:\tb8 14 00 00 00       \tmov    $0x14,%eax\n 34f:\tcd 40                \tint    $0x40\n 351:\tc3                   \tret    \n\n00000352 <chdir>:\nSYSCALL(chdir)\n 352:\tb8 09 00 00 00       \tmov    $0x9,%eax\n 357:\tcd 40                \tint    $0x40\n 359:\tc3                   \tret    \n\n0000035a <dup>:\nSYSCALL(dup)\n 35a:\tb8 0a 00 00 00       \tmov    $0xa,%eax\n 35f:\tcd 40                \tint    $0x40\n 361:\tc3                   \tret    \n\n00000362 <getpid>:\nSYSCALL(getpid)\n 362:\tb8 0b 00 00 00       \tmov    $0xb,%eax\n 367:\tcd 40                \tint    $0x40\n 369:\tc3                   \tret    \n\n0000036a <sbrk>:\nSYSCALL(sbrk)\n 36a:\tb8 0c 00 00 00       \tmov    $0xc,%eax\n 36f:\tcd 40                \tint    $0x40\n 371:\tc3                   \tret    \n\n00000372 <sleep>:\nSYSCALL(sleep)\n 372:\tb8 0d 00 00 00       \tmov    $0xd,%eax\n 377:\tcd 40                \tint    $0x40\n 379:\tc3                   \tret    \n\n0000037a <uptime>:\nSYSCALL(uptime)\n 37a:\tb8 0e 00 00 00       \tmov    $0xe,%eax\n 37f:\tcd 40                \tint    $0x40\n 381:\tc3                   \tret    \n\n00000382 <lottery>:\n 382:\tb8 16 00 00 00       \tmov    $0x16,%eax\n 387:\tcd 40                \tint    $0x40\n 389:\tc3                   \tret    \n 38a:\t66 90                \txchg   %ax,%ax\n 38c:\t66 90                \txchg   %ax,%ax\n 38e:\t66 90                \txchg   %ax,%ax\n\n00000390 <printint>:\n  write(fd, &c, 1);\n}\n\nstatic void\nprintint(int fd, int xx, int base, int sgn)\n{\n 390:\t55                   \tpush   %ebp\n 391:\t89 e5                \tmov    %esp,%ebp\n 393:\t57                   \tpush   %edi\n 394:\t56                   \tpush   %esi\n 395:\t53                   \tpush   %ebx\n 396:\t83 ec 3c             \tsub    $0x3c,%esp\n  char buf[16];\n  int i, neg;\n  uint x;\n\n  neg = 0;\n  if(sgn && xx < 0){\n 399:\t85 d2                \ttest   %edx,%edx\n{\n 39b:\t89 45 c0             \tmov    %eax,-0x40(%ebp)\n    neg = 1;\n    x = -xx;\n 39e:\t89 d0                \tmov    %edx,%eax\n  if(sgn && xx < 0){\n 3a0:\t79 76                \tjns    418 <printint+0x88>\n 3a2:\tf6 45 08 01          \ttestb  $0x1,0x8(%ebp)\n 3a6:\t74 70                \tje     418 <printint+0x88>\n    x = -xx;\n 3a8:\tf7 d8                \tneg    %eax\n    neg = 1;\n 3aa:\tc7 45 c4 01 00 00 00 \tmovl   $0x1,-0x3c(%ebp)\n  } else {\n    x = xx;\n  }\n\n  i = 0;\n 3b1:\t31 f6                \txor    %esi,%esi\n 3b3:\t8d 5d d7             \tlea    -0x29(%ebp),%ebx\n 3b6:\teb 0a                \tjmp    3c2 <printint+0x32>\n 3b8:\t90                   \tnop\n 3b9:\t8d b4 26 00 00 00 00 \tlea    0x0(%esi,%eiz,1),%esi\n  do{\n    buf[i++] = digits[x % base];\n 3c0:\t89 fe                \tmov    %edi,%esi\n 3c2:\t31 d2                \txor    %edx,%edx\n 3c4:\t8d 7e 01             \tlea    0x1(%esi),%edi\n 3c7:\tf7 f1                \tdiv    %ecx\n 3c9:\t0f b6 92 90 07 00 00 \tmovzbl 0x790(%edx),%edx\n  }while((x /= base) != 0);\n 3d0:\t85 c0                \ttest   %eax,%eax\n    buf[i++] = digits[x % base];\n 3d2:\t88 14 3b             \tmov    %dl,(%ebx,%edi,1)\n  }while((x /= base) != 0);\n 3d5:\t75 e9                \tjne    3c0 <printint+0x30>\n  if(neg)\n 3d7:\t8b 45 c4             \tmov    -0x3c(%ebp),%eax\n 3da:\t85 c0                \ttest   %eax,%eax\n 3dc:\t74 08                \tje     3e6 <printint+0x56>\n    buf[i++] = '-';\n 3de:\tc6 44 3d d8 2d       \tmovb   $0x2d,-0x28(%ebp,%edi,1)\n 3e3:\t8d 7e 02             \tlea    0x2(%esi),%edi\n 3e6:\t8d 74 3d d7          \tlea    -0x29(%ebp,%edi,1),%esi\n 3ea:\t8b 7d c0             \tmov    -0x40(%ebp),%edi\n 3ed:\t8d 76 00             \tlea    0x0(%esi),%esi\n 3f0:\t0f b6 06             \tmovzbl (%esi),%eax\n  write(fd, &c, 1);\n 3f3:\t83 ec 04             \tsub    $0x4,%esp\n 3f6:\t83 ee 01             \tsub    $0x1,%esi\n 3f9:\t6a 01                \tpush   $0x1\n 3fb:\t53                   \tpush   %ebx\n 3fc:\t57                   \tpush   %edi\n 3fd:\t88 45 d7             \tmov    %al,-0x29(%ebp)\n 400:\te8 fd fe ff ff       \tcall   302 <write>\n\n  while(--i >= 0)\n 405:\t83 c4 10             \tadd    $0x10,%esp\n 408:\t39 de                \tcmp    %ebx,%esi\n 40a:\t75 e4                \tjne    3f0 <printint+0x60>\n    putc(fd, buf[i]);\n}\n 40c:\t8d 65 f4             \tlea    -0xc(%ebp),%esp\n 40f:\t5b                   \tpop    %ebx\n 410:\t5e                   \tpop    %esi\n 411:\t5f                   \tpop    %edi\n 412:\t5d                   \tpop    %ebp\n 413:\tc3                   \tret    \n 414:\t8d 74 26 00          \tlea    0x0(%esi,%eiz,1),%esi\n  neg = 0;\n 418:\tc7 45 c4 00 00 00 00 \tmovl   $0x0,-0x3c(%ebp)\n 41f:\teb 90                \tjmp    3b1 <printint+0x21>\n 421:\teb 0d                \tjmp    430 <printf>\n 423:\t90                   \tnop\n 424:\t90                   \tnop\n 425:\t90                   \tnop\n 426:\t90                   \tnop\n 427:\t90                   \tnop\n 428:\t90                   \tnop\n 429:\t90                   \tnop\n 42a:\t90                   \tnop\n 42b:\t90                   \tnop\n 42c:\t90                   \tnop\n 42d:\t90                   \tnop\n 42e:\t90                   \tnop\n 42f:\t90                   \tnop\n\n00000430 <printf>:\n\n// Print to the given fd. Only understands %d, %x, %p, %s.\nvoid\nprintf(int fd, const char *fmt, ...)\n{\n 430:\t55                   \tpush   %ebp\n 431:\t89 e5                \tmov    %esp,%ebp\n 433:\t57                   \tpush   %edi\n 434:\t56                   \tpush   %esi\n 435:\t53                   \tpush   %ebx\n 436:\t83 ec 2c             \tsub    $0x2c,%esp\n  int c, i, state;\n  uint *ap;\n\n  state = 0;\n  ap = (uint*)(void*)&fmt + 1;\n  for(i = 0; fmt[i]; i++){\n 439:\t8b 75 0c             \tmov    0xc(%ebp),%esi\n 43c:\t0f b6 1e             \tmovzbl (%esi),%ebx\n 43f:\t84 db                \ttest   %bl,%bl\n 441:\t0f 84 b3 00 00 00    \tje     4fa <printf+0xca>\n  ap = (uint*)(void*)&fmt + 1;\n 447:\t8d 45 10             \tlea    0x10(%ebp),%eax\n 44a:\t83 c6 01             \tadd    $0x1,%esi\n  state = 0;\n 44d:\t31 ff                \txor    %edi,%edi\n  ap = (uint*)(void*)&fmt + 1;\n 44f:\t89 45 d4             \tmov    %eax,-0x2c(%ebp)\n 452:\teb 2f                \tjmp    483 <printf+0x53>\n 454:\t8d 74 26 00          \tlea    0x0(%esi,%eiz,1),%esi\n    c = fmt[i] & 0xff;\n    if(state == 0){\n      if(c == '%'){\n 458:\t83 f8 25             \tcmp    $0x25,%eax\n 45b:\t0f 84 a7 00 00 00    \tje     508 <printf+0xd8>\n  write(fd, &c, 1);\n 461:\t8d 45 e2             \tlea    -0x1e(%ebp),%eax\n 464:\t83 ec 04             \tsub    $0x4,%esp\n 467:\t88 5d e2             \tmov    %bl,-0x1e(%ebp)\n 46a:\t6a 01                \tpush   $0x1\n 46c:\t50                   \tpush   %eax\n 46d:\tff 75 08             \tpushl  0x8(%ebp)\n 470:\te8 8d fe ff ff       \tcall   302 <write>\n 475:\t83 c4 10             \tadd    $0x10,%esp\n 478:\t83 c6 01             \tadd    $0x1,%esi\n  for(i = 0; fmt[i]; i++){\n 47b:\t0f b6 5e ff          \tmovzbl -0x1(%esi),%ebx\n 47f:\t84 db                \ttest   %bl,%bl\n 481:\t74 77                \tje     4fa <printf+0xca>\n    if(state == 0){\n 483:\t85 ff                \ttest   %edi,%edi\n    c = fmt[i] & 0xff;\n 485:\t0f be cb             \tmovsbl %bl,%ecx\n 488:\t0f b6 c3             \tmovzbl %bl,%eax\n    if(state == 0){\n 48b:\t74 cb                \tje     458 <printf+0x28>\n        state = '%';\n      } else {\n        putc(fd, c);\n      }\n    } else if(state == '%'){\n 48d:\t83 ff 25             \tcmp    $0x25,%edi\n 490:\t75 e6                \tjne    478 <printf+0x48>\n      if(c == 'd'){\n 492:\t83 f8 64             \tcmp    $0x64,%eax\n 495:\t0f 84 05 01 00 00    \tje     5a0 <printf+0x170>\n        printint(fd, *ap, 10, 1);\n        ap++;\n      } else if(c == 'x' || c == 'p'){\n 49b:\t81 e1 f7 00 00 00    \tand    $0xf7,%ecx\n 4a1:\t83 f9 70             \tcmp    $0x70,%ecx\n 4a4:\t74 72                \tje     518 <printf+0xe8>\n        printint(fd, *ap, 16, 0);\n        ap++;\n      } else if(c == 's'){\n 4a6:\t83 f8 73             \tcmp    $0x73,%eax\n 4a9:\t0f 84 99 00 00 00    \tje     548 <printf+0x118>\n          s = \"(null)\";\n        while(*s != 0){\n          putc(fd, *s);\n          s++;\n        }\n      } else if(c == 'c'){\n 4af:\t83 f8 63             \tcmp    $0x63,%eax\n 4b2:\t0f 84 08 01 00 00    \tje     5c0 <printf+0x190>\n        putc(fd, *ap);\n        ap++;\n      } else if(c == '%'){\n 4b8:\t83 f8 25             \tcmp    $0x25,%eax\n 4bb:\t0f 84 ef 00 00 00    \tje     5b0 <printf+0x180>\n  write(fd, &c, 1);\n 4c1:\t8d 45 e7             \tlea    -0x19(%ebp),%eax\n 4c4:\t83 ec 04             \tsub    $0x4,%esp\n 4c7:\tc6 45 e7 25          \tmovb   $0x25,-0x19(%ebp)\n 4cb:\t6a 01                \tpush   $0x1\n 4cd:\t50                   \tpush   %eax\n 4ce:\tff 75 08             \tpushl  0x8(%ebp)\n 4d1:\te8 2c fe ff ff       \tcall   302 <write>\n 4d6:\t83 c4 0c             \tadd    $0xc,%esp\n 4d9:\t8d 45 e6             \tlea    -0x1a(%ebp),%eax\n 4dc:\t88 5d e6             \tmov    %bl,-0x1a(%ebp)\n 4df:\t6a 01                \tpush   $0x1\n 4e1:\t50                   \tpush   %eax\n 4e2:\tff 75 08             \tpushl  0x8(%ebp)\n 4e5:\t83 c6 01             \tadd    $0x1,%esi\n      } else {\n        // Unknown % sequence.  Print it to draw attention.\n        putc(fd, '%');\n        putc(fd, c);\n      }\n      state = 0;\n 4e8:\t31 ff                \txor    %edi,%edi\n  write(fd, &c, 1);\n 4ea:\te8 13 fe ff ff       \tcall   302 <write>\n  for(i = 0; fmt[i]; i++){\n 4ef:\t0f b6 5e ff          \tmovzbl -0x1(%esi),%ebx\n  write(fd, &c, 1);\n 4f3:\t83 c4 10             \tadd    $0x10,%esp\n  for(i = 0; fmt[i]; i++){\n 4f6:\t84 db                \ttest   %bl,%bl\n 4f8:\t75 89                \tjne    483 <printf+0x53>\n    }\n  }\n}\n 4fa:\t8d 65 f4             \tlea    -0xc(%ebp),%esp\n 4fd:\t5b                   \tpop    %ebx\n 4fe:\t5e                   \tpop    %esi\n 4ff:\t5f                   \tpop    %edi\n 500:\t5d                   \tpop    %ebp\n 501:\tc3                   \tret    \n 502:\t8d b6 00 00 00 00    \tlea    0x0(%esi),%esi\n        state = '%';\n 508:\tbf 25 00 00 00       \tmov    $0x25,%edi\n 50d:\te9 66 ff ff ff       \tjmp    478 <printf+0x48>\n 512:\t8d b6 00 00 00 00    \tlea    0x0(%esi),%esi\n        printint(fd, *ap, 16, 0);\n 518:\t83 ec 0c             \tsub    $0xc,%esp\n 51b:\tb9 10 00 00 00       \tmov    $0x10,%ecx\n 520:\t6a 00                \tpush   $0x0\n 522:\t8b 7d d4             \tmov    -0x2c(%ebp),%edi\n 525:\t8b 45 08             \tmov    0x8(%ebp),%eax\n 528:\t8b 17                \tmov    (%edi),%edx\n 52a:\te8 61 fe ff ff       \tcall   390 <printint>\n        ap++;\n 52f:\t89 f8                \tmov    %edi,%eax\n 531:\t83 c4 10             \tadd    $0x10,%esp\n      state = 0;\n 534:\t31 ff                \txor    %edi,%edi\n        ap++;\n 536:\t83 c0 04             \tadd    $0x4,%eax\n 539:\t89 45 d4             \tmov    %eax,-0x2c(%ebp)\n 53c:\te9 37 ff ff ff       \tjmp    478 <printf+0x48>\n 541:\t8d b4 26 00 00 00 00 \tlea    0x0(%esi,%eiz,1),%esi\n        s = (char*)*ap;\n 548:\t8b 45 d4             \tmov    -0x2c(%ebp),%eax\n 54b:\t8b 08                \tmov    (%eax),%ecx\n        ap++;\n 54d:\t83 c0 04             \tadd    $0x4,%eax\n 550:\t89 45 d4             \tmov    %eax,-0x2c(%ebp)\n        if(s == 0)\n 553:\t85 c9                \ttest   %ecx,%ecx\n 555:\t0f 84 8e 00 00 00    \tje     5e9 <printf+0x1b9>\n        while(*s != 0){\n 55b:\t0f b6 01             \tmovzbl (%ecx),%eax\n      state = 0;\n 55e:\t31 ff                \txor    %edi,%edi\n        s = (char*)*ap;\n 560:\t89 cb                \tmov    %ecx,%ebx\n        while(*s != 0){\n 562:\t84 c0                \ttest   %al,%al\n 564:\t0f 84 0e ff ff ff    \tje     478 <printf+0x48>\n 56a:\t89 75 d0             \tmov    %esi,-0x30(%ebp)\n 56d:\t89 de                \tmov    %ebx,%esi\n 56f:\t8b 5d 08             \tmov    0x8(%ebp),%ebx\n 572:\t8d 7d e3             \tlea    -0x1d(%ebp),%edi\n 575:\t8d 76 00             \tlea    0x0(%esi),%esi\n  write(fd, &c, 1);\n 578:\t83 ec 04             \tsub    $0x4,%esp\n          s++;\n 57b:\t83 c6 01             \tadd    $0x1,%esi\n 57e:\t88 45 e3             \tmov    %al,-0x1d(%ebp)\n  write(fd, &c, 1);\n 581:\t6a 01                \tpush   $0x1\n 583:\t57                   \tpush   %edi\n 584:\t53                   \tpush   %ebx\n 585:\te8 78 fd ff ff       \tcall   302 <write>\n        while(*s != 0){\n 58a:\t0f b6 06             \tmovzbl (%esi),%eax\n 58d:\t83 c4 10             \tadd    $0x10,%esp\n 590:\t84 c0                \ttest   %al,%al\n 592:\t75 e4                \tjne    578 <printf+0x148>\n 594:\t8b 75 d0             \tmov    -0x30(%ebp),%esi\n      state = 0;\n 597:\t31 ff                \txor    %edi,%edi\n 599:\te9 da fe ff ff       \tjmp    478 <printf+0x48>\n 59e:\t66 90                \txchg   %ax,%ax\n        printint(fd, *ap, 10, 1);\n 5a0:\t83 ec 0c             \tsub    $0xc,%esp\n 5a3:\tb9 0a 00 00 00       \tmov    $0xa,%ecx\n 5a8:\t6a 01                \tpush   $0x1\n 5aa:\te9 73 ff ff ff       \tjmp    522 <printf+0xf2>\n 5af:\t90                   \tnop\n  write(fd, &c, 1);\n 5b0:\t83 ec 04             \tsub    $0x4,%esp\n 5b3:\t88 5d e5             \tmov    %bl,-0x1b(%ebp)\n 5b6:\t8d 45 e5             \tlea    -0x1b(%ebp),%eax\n 5b9:\t6a 01                \tpush   $0x1\n 5bb:\te9 21 ff ff ff       \tjmp    4e1 <printf+0xb1>\n        putc(fd, *ap);\n 5c0:\t8b 7d d4             \tmov    -0x2c(%ebp),%edi\n  write(fd, &c, 1);\n 5c3:\t83 ec 04             \tsub    $0x4,%esp\n        putc(fd, *ap);\n 5c6:\t8b 07                \tmov    (%edi),%eax\n  write(fd, &c, 1);\n 5c8:\t6a 01                \tpush   $0x1\n        ap++;\n 5ca:\t83 c7 04             \tadd    $0x4,%edi\n        putc(fd, *ap);\n 5cd:\t88 45 e4             \tmov    %al,-0x1c(%ebp)\n  write(fd, &c, 1);\n 5d0:\t8d 45 e4             \tlea    -0x1c(%ebp),%eax\n 5d3:\t50                   \tpush   %eax\n 5d4:\tff 75 08             \tpushl  0x8(%ebp)\n 5d7:\te8 26 fd ff ff       \tcall   302 <write>\n        ap++;\n 5dc:\t89 7d d4             \tmov    %edi,-0x2c(%ebp)\n 5df:\t83 c4 10             \tadd    $0x10,%esp\n      state = 0;\n 5e2:\t31 ff                \txor    %edi,%edi\n 5e4:\te9 8f fe ff ff       \tjmp    478 <printf+0x48>\n          s = \"(null)\";\n 5e9:\tbb 88 07 00 00       \tmov    $0x788,%ebx\n        while(*s != 0){\n 5ee:\tb8 28 00 00 00       \tmov    $0x28,%eax\n 5f3:\te9 72 ff ff ff       \tjmp    56a <printf+0x13a>\n 5f8:\t66 90                \txchg   %ax,%ax\n 5fa:\t66 90                \txchg   %ax,%ax\n 5fc:\t66 90                \txchg   %ax,%ax\n 5fe:\t66 90                \txchg   %ax,%ax\n\n00000600 <free>:\nstatic Header base;\nstatic Header *freep;\n\nvoid\nfree(void *ap)\n{\n 600:\t55                   \tpush   %ebp\n  Header *bp, *p;\n\n  bp = (Header*)ap - 1;\n  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)\n 601:\ta1 58 0a 00 00       \tmov    0xa58,%eax\n{\n 606:\t89 e5                \tmov    %esp,%ebp\n 608:\t57                   \tpush   %edi\n 609:\t56                   \tpush   %esi\n 60a:\t53                   \tpush   %ebx\n 60b:\t8b 5d 08             \tmov    0x8(%ebp),%ebx\n  bp = (Header*)ap - 1;\n 60e:\t8d 4b f8             \tlea    -0x8(%ebx),%ecx\n 611:\t8d b4 26 00 00 00 00 \tlea    0x0(%esi,%eiz,1),%esi\n  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)\n 618:\t39 c8                \tcmp    %ecx,%eax\n 61a:\t8b 10                \tmov    (%eax),%edx\n 61c:\t73 32                \tjae    650 <free+0x50>\n 61e:\t39 d1                \tcmp    %edx,%ecx\n 620:\t72 04                \tjb     626 <free+0x26>\n    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))\n 622:\t39 d0                \tcmp    %edx,%eax\n 624:\t72 32                \tjb     658 <free+0x58>\n      break;\n  if(bp + bp->s.size == p->s.ptr){\n 626:\t8b 73 fc             \tmov    -0x4(%ebx),%esi\n 629:\t8d 3c f1             \tlea    (%ecx,%esi,8),%edi\n 62c:\t39 fa                \tcmp    %edi,%edx\n 62e:\t74 30                \tje     660 <free+0x60>\n    bp->s.size += p->s.ptr->s.size;\n    bp->s.ptr = p->s.ptr->s.ptr;\n  } else\n    bp->s.ptr = p->s.ptr;\n 630:\t89 53 f8             \tmov    %edx,-0x8(%ebx)\n  if(p + p->s.size == bp){\n 633:\t8b 50 04             \tmov    0x4(%eax),%edx\n 636:\t8d 34 d0             \tlea    (%eax,%edx,8),%esi\n 639:\t39 f1                \tcmp    %esi,%ecx\n 63b:\t74 3a                \tje     677 <free+0x77>\n    p->s.size += bp->s.size;\n    p->s.ptr = bp->s.ptr;\n  } else\n    p->s.ptr = bp;\n 63d:\t89 08                \tmov    %ecx,(%eax)\n  freep = p;\n 63f:\ta3 58 0a 00 00       \tmov    %eax,0xa58\n}\n 644:\t5b                   \tpop    %ebx\n 645:\t5e                   \tpop    %esi\n 646:\t5f                   \tpop    %edi\n 647:\t5d                   \tpop    %ebp\n 648:\tc3                   \tret    \n 649:\t8d b4 26 00 00 00 00 \tlea    0x0(%esi,%eiz,1),%esi\n    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))\n 650:\t39 d0                \tcmp    %edx,%eax\n 652:\t72 04                \tjb     658 <free+0x58>\n 654:\t39 d1                \tcmp    %edx,%ecx\n 656:\t72 ce                \tjb     626 <free+0x26>\n{\n 658:\t89 d0                \tmov    %edx,%eax\n 65a:\teb bc                \tjmp    618 <free+0x18>\n 65c:\t8d 74 26 00          \tlea    0x0(%esi,%eiz,1),%esi\n    bp->s.size += p->s.ptr->s.size;\n 660:\t03 72 04             \tadd    0x4(%edx),%esi\n 663:\t89 73 fc             \tmov    %esi,-0x4(%ebx)\n    bp->s.ptr = p->s.ptr->s.ptr;\n 666:\t8b 10                \tmov    (%eax),%edx\n 668:\t8b 12                \tmov    (%edx),%edx\n 66a:\t89 53 f8             \tmov    %edx,-0x8(%ebx)\n  if(p + p->s.size == bp){\n 66d:\t8b 50 04             \tmov    0x4(%eax),%edx\n 670:\t8d 34 d0             \tlea    (%eax,%edx,8),%esi\n 673:\t39 f1                \tcmp    %esi,%ecx\n 675:\t75 c6                \tjne    63d <free+0x3d>\n    p->s.size += bp->s.size;\n 677:\t03 53 fc             \tadd    -0x4(%ebx),%edx\n  freep = p;\n 67a:\ta3 58 0a 00 00       \tmov    %eax,0xa58\n    p->s.size += bp->s.size;\n 67f:\t89 50 04             \tmov    %edx,0x4(%eax)\n    p->s.ptr = bp->s.ptr;\n 682:\t8b 53 f8             \tmov    -0x8(%ebx),%edx\n 685:\t89 10                \tmov    %edx,(%eax)\n}\n 687:\t5b                   \tpop    %ebx\n 688:\t5e                   \tpop    %esi\n 689:\t5f                   \tpop    %edi\n 68a:\t5d                   \tpop    %ebp\n 68b:\tc3                   \tret    \n 68c:\t8d 74 26 00          \tlea    0x0(%esi,%eiz,1),%esi\n\n00000690 <malloc>:\n  return freep;\n}\n\nvoid*\nmalloc(uint nbytes)\n{\n 690:\t55                   \tpush   %ebp\n 691:\t89 e5                \tmov    %esp,%ebp\n 693:\t57                   \tpush   %edi\n 694:\t56                   \tpush   %esi\n 695:\t53                   \tpush   %ebx\n 696:\t83 ec 0c             \tsub    $0xc,%esp\n  Header *p, *prevp;\n  uint nunits;\n\n  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;\n 699:\t8b 45 08             \tmov    0x8(%ebp),%eax\n  if((prevp = freep) == 0){\n 69c:\t8b 15 58 0a 00 00    \tmov    0xa58,%edx\n  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;\n 6a2:\t8d 78 07             \tlea    0x7(%eax),%edi\n 6a5:\tc1 ef 03             \tshr    $0x3,%edi\n 6a8:\t83 c7 01             \tadd    $0x1,%edi\n  if((prevp = freep) == 0){\n 6ab:\t85 d2                \ttest   %edx,%edx\n 6ad:\t0f 84 9d 00 00 00    \tje     750 <malloc+0xc0>\n 6b3:\t8b 02                \tmov    (%edx),%eax\n 6b5:\t8b 48 04             \tmov    0x4(%eax),%ecx\n    base.s.ptr = freep = prevp = &base;\n    base.s.size = 0;\n  }\n  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){\n    if(p->s.size >= nunits){\n 6b8:\t39 cf                \tcmp    %ecx,%edi\n 6ba:\t76 6c                \tjbe    728 <malloc+0x98>\n 6bc:\t81 ff 00 10 00 00    \tcmp    $0x1000,%edi\n 6c2:\tbb 00 10 00 00       \tmov    $0x1000,%ebx\n 6c7:\t0f 43 df             \tcmovae %edi,%ebx\n  p = sbrk(nu * sizeof(Header));\n 6ca:\t8d 34 dd 00 00 00 00 \tlea    0x0(,%ebx,8),%esi\n 6d1:\teb 0e                \tjmp    6e1 <malloc+0x51>\n 6d3:\t90                   \tnop\n 6d4:\t8d 74 26 00          \tlea    0x0(%esi,%eiz,1),%esi\n  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){\n 6d8:\t8b 02                \tmov    (%edx),%eax\n    if(p->s.size >= nunits){\n 6da:\t8b 48 04             \tmov    0x4(%eax),%ecx\n 6dd:\t39 f9                \tcmp    %edi,%ecx\n 6df:\t73 47                \tjae    728 <malloc+0x98>\n        p->s.size = nunits;\n      }\n      freep = prevp;\n      return (void*)(p + 1);\n    }\n    if(p == freep)\n 6e1:\t39 05 58 0a 00 00    \tcmp    %eax,0xa58\n 6e7:\t89 c2                \tmov    %eax,%edx\n 6e9:\t75 ed                \tjne    6d8 <malloc+0x48>\n  p = sbrk(nu * sizeof(Header));\n 6eb:\t83 ec 0c             \tsub    $0xc,%esp\n 6ee:\t56                   \tpush   %esi\n 6ef:\te8 76 fc ff ff       \tcall   36a <sbrk>\n  if(p == (char*)-1)\n 6f4:\t83 c4 10             \tadd    $0x10,%esp\n 6f7:\t83 f8 ff             \tcmp    $0xffffffff,%eax\n 6fa:\t74 1c                \tje     718 <malloc+0x88>\n  hp->s.size = nu;\n 6fc:\t89 58 04             \tmov    %ebx,0x4(%eax)\n  free((void*)(hp + 1));\n 6ff:\t83 ec 0c             \tsub    $0xc,%esp\n 702:\t83 c0 08             \tadd    $0x8,%eax\n 705:\t50                   \tpush   %eax\n 706:\te8 f5 fe ff ff       \tcall   600 <free>\n  return freep;\n 70b:\t8b 15 58 0a 00 00    \tmov    0xa58,%edx\n      if((p = morecore(nunits)) == 0)\n 711:\t83 c4 10             \tadd    $0x10,%esp\n 714:\t85 d2                \ttest   %edx,%edx\n 716:\t75 c0                \tjne    6d8 <malloc+0x48>\n        return 0;\n  }\n}\n 718:\t8d 65 f4             \tlea    -0xc(%ebp),%esp\n        return 0;\n 71b:\t31 c0                \txor    %eax,%eax\n}\n 71d:\t5b                   \tpop    %ebx\n 71e:\t5e                   \tpop    %esi\n 71f:\t5f                   \tpop    %edi\n 720:\t5d                   \tpop    %ebp\n 721:\tc3                   \tret    \n 722:\t8d b6 00 00 00 00    \tlea    0x0(%esi),%esi\n      if(p->s.size == nunits)\n 728:\t39 cf                \tcmp    %ecx,%edi\n 72a:\t74 54                \tje     780 <malloc+0xf0>\n        p->s.size -= nunits;\n 72c:\t29 f9                \tsub    %edi,%ecx\n 72e:\t89 48 04             \tmov    %ecx,0x4(%eax)\n        p += p->s.size;\n 731:\t8d 04 c8             \tlea    (%eax,%ecx,8),%eax\n        p->s.size = nunits;\n 734:\t89 78 04             \tmov    %edi,0x4(%eax)\n      freep = prevp;\n 737:\t89 15 58 0a 00 00    \tmov    %edx,0xa58\n}\n 73d:\t8d 65 f4             \tlea    -0xc(%ebp),%esp\n      return (void*)(p + 1);\n 740:\t83 c0 08             \tadd    $0x8,%eax\n}\n 743:\t5b                   \tpop    %ebx\n 744:\t5e                   \tpop    %esi\n 745:\t5f                   \tpop    %edi\n 746:\t5d                   \tpop    %ebp\n 747:\tc3                   \tret    \n 748:\t90                   \tnop\n 749:\t8d b4 26 00 00 00 00 \tlea    0x0(%esi,%eiz,1),%esi\n    base.s.ptr = freep = prevp = &base;\n 750:\tc7 05 58 0a 00 00 5c \tmovl   $0xa5c,0xa58\n 757:\t0a 00 00 \n 75a:\tc7 05 5c 0a 00 00 5c \tmovl   $0xa5c,0xa5c\n 761:\t0a 00 00 \n    base.s.size = 0;\n 764:\tb8 5c 0a 00 00       \tmov    $0xa5c,%eax\n 769:\tc7 05 60 0a 00 00 00 \tmovl   $0x0,0xa60\n 770:\t00 00 00 \n 773:\te9 44 ff ff ff       \tjmp    6bc <malloc+0x2c>\n 778:\t90                   \tnop\n 779:\t8d b4 26 00 00 00 00 \tlea    0x0(%esi,%eiz,1),%esi\n        prevp->s.ptr = p->s.ptr;\n 780:\t8b 08                \tmov    (%eax),%ecx\n 782:\t89 0a                \tmov    %ecx,(%edx)\n 784:\teb b1                \tjmp    737 <malloc+0xa7>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lottery.asm	(revision 17a8e6bb63a06a9550a3a8e578bdc59941b295f1)
+++ lottery.asm	(date 1538323169000)
@@ -5,7 +5,7 @@
 Desmontagem da seção .text:
 
 00000000 <main>:
-
+#define QTD_PROC    10
 
 void process_test(int tickets);
 
Index: param.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#define NPROC        64  // maximum number of processes\n#define KSTACKSIZE 4096  // size of per-process kernel stack\n#define NCPU          1  // maximum number of CPUs\n#define NOFILE       16  // open files per process\n#define NFILE       100  // open files per system\n#define NINODE       50  // maximum number of active i-nodes\n#define NDEV         10  // maximum major device number\n#define ROOTDEV       1  // device number of file system root disk\n#define MAXARG       32  // max exec arguments\n#define MAXOPBLOCKS  10  // max # of blocks any FS op writes\n#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log\n#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache\n#define FSSIZE       1000  // size of file system in blocks\n#define NTICKETS     (NPROC/NCPU) // default per-process tickets\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- param.h	(revision 17a8e6bb63a06a9550a3a8e578bdc59941b295f1)
+++ param.h	(date 1538323169000)
@@ -11,4 +11,4 @@
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
-#define NTICKETS     (NPROC/NCPU) // default per-process tickets
+#define NTICKETS     (NPROC/NCPU) // quantidade de tickts para inicialização.
Index: README
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>UFFS - Campus Chapecó - Curso de Ciência da Computação\n\nGRUPO: Bruno Ribeiro e Lucas Percisi.\n\nCCR: Sistemas Operacionais – 2018.2 - Prof. Marco Aurélio Spohn\nDescrição/Especificação dos Trabalhos I e II\n\nObjetivo geral: desenvolver conhecimento e prática de implementação de um componente básico (i.e.,\nescalonador de processos) em um sistema operacional didático.\nObjetivos específicos: a) estudar o código de uma implementação do Unix versão 6 para a plataforma Intel\n(xv6, desenvolvido no MIT); b) analisar e planejar a implementação de dois escalonadores de processos; c)\nimplementar os escalonadores; d) avaliar os escalonadores através de experimentos; e) elaborar relatórios\ndescritivos para cada um dos trabalhos.\n\nPlataforma: xv6 → http://pdos.csail.mit.edu/6.828/2012/xv6.html\nModalidade: individual OU dupla (avaliação sempre será individual!)\n\nDescrição do Trabalho I: Implementar o escalonador de processos baseado em loteria (lottery\nscheduling). Na instanciação de um processo, deve-se passar ao sistema a quantidade de bilhetes\nque o novo processo recebe. Caso o usuário não forneça esse dado, o sistema assume um número\ndefault de bilhetes. Assumir também um número máximo de bilhetes que um processo pode receber.\n\n\nINSTRUÇÕES:\n\n1 - Dentro da pasta 'xv6-public' execute o comando $ 'make; make qemu-nox'\n\n2 - Aguarde o sistema iniciar a faça a chamada de sistema 'lottery'\n\n3 - Será exibido uma tabela periodicamente com as informações dos processos:\n\n    Exemplo:\n\n    PID     | NAME          | STATE         | QTD_T | OC    | PROC  | ESTI  |\n    1       | init          | sleep         | 0     |27     | 0%    | 0%    |\n    2       | sh            | sleep         | 64    |17     | 0%    | 0%    |\n    3       | lottery       | runable       | 64    |17     | 0%    | 0%    |\n    4       | lottery       | runable       | 100   |20     | 0%    | 0%    |\n    5       | lottery       | runable       | 400   |67     | 1%    | 1%    |\n    6       | lottery       | runable       | 900   |148    | 2%    | 2%    |\n    7       | lottery       | runable       | 1600  |240    | 3%    | 4%    |\n    8       | lottery       | runable       | 2500  |367    | 5%    | 6%    |\n    9       | lottery       | runable       | 3600  |573    | 9%    | 9%    |\n    10      | lottery       | runable       | 4900  |803    | 13%   | 12%   |\n    11      | lottery       | runable       | 6400  |1011   | 16%   | 16%   |\n    12      | lottery       | runable       | 8100  |1300   | 21%   | 21%   |\n    13      | lottery       | runable       | 10000 |1580   | 25%   | 25%   |\n    14      | lottery       | runable       | 1     |0      | 0%    | 0%    |\n\n    PID     = Id do processo\n    NAME    = Nome da chamada de sistema\n    STATE   = Estado do processo\n    QTD_D   = Quantidade de bilhetes que o processo recebeu\n    OC      = Quantidade de vezes que o processo ganhou a CPU\n    PROC    = Porcentagem de uso da CPU\n    ESTI    = Estimativa de uso da CPU para cada processo em % após estabilização das occorrências.\n\n\n4 - Para alterar a quantidade de processos para teste, abra o arquivo 'lottery.c'\n    e mude a macro QTD_PROC para a quantidade desejada.\n\n5 - Os processos recebem bilhetes de forma quadrática conforme instânciados.\n    Se deseja mudar isso, altera a linha 20 do arquivo lottery.c\n\n6 - Para finalizar os testes pressione ctrl-a e depois pressione x.\n\n\n\n###################################################################################\n###################################################################################\n###################################################################################\nxv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix\nVersion 6 (v6).  xv6 loosely follows the structure and style of v6,\nbut is implemented for a modern x86-based multiprocessor using ANSI C.\n\nACKNOWLEDGMENTS\n\nxv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer\nto Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,\n2000)). See also https://pdos.csail.mit.edu/6.828/, which\nprovides pointers to on-line resources for v6.\n\nxv6 borrows code from the following sources:\n    JOS (asm.h, elf.h, mmu.h, bootasm.S, ide.c, console.c, and others)\n    Plan 9 (entryother.S, mp.h, mp.c, lapic.c)\n    FreeBSD (ioapic.c)\n    NetBSD (console.c)\n\nThe following people have made contributions: Russ Cox (context switching,\nlocking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin\nClements.\n\nWe are also grateful for the bug reports and patches contributed by Silas\nBoyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,\nNelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter\nFroehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander\nKapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin\nLiew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi\nMerimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,\nEldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren\nToomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas\nWolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.\n\nThe code in the files that constitute xv6 is\nCopyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.\n\nERROR REPORTS\n\nPlease send errors and suggestions to Frans Kaashoek and Robert Morris\n(kaashoek,rtm@mit.edu). The main purpose of xv6 is as a teaching\noperating system for MIT's 6.828, so we are more interested in\nsimplifications and clarifications than new features.\n\nBUILDING AND RUNNING XV6\n\nTo build xv6 on an x86 ELF machine (like Linux or FreeBSD), run\n\"make\". On non-x86 or non-ELF machines (like OS X, even on x86), you\nwill need to install a cross-compiler gcc suite capable of producing\nx86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).\nThen run \"make TOOLPREFIX=i386-jos-elf-\". Now install the QEMU PC\nsimulator and run \"make qemu\".\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- README	(revision 17a8e6bb63a06a9550a3a8e578bdc59941b295f1)
+++ README	(date 1538323169000)
@@ -1,74 +1,3 @@
-UFFS - Campus Chapecó - Curso de Ciência da Computação
-
-GRUPO: Bruno Ribeiro e Lucas Percisi.
-
-CCR: Sistemas Operacionais – 2018.2 - Prof. Marco Aurélio Spohn
-Descrição/Especificação dos Trabalhos I e II
-
-Objetivo geral: desenvolver conhecimento e prática de implementação de um componente básico (i.e.,
-escalonador de processos) em um sistema operacional didático.
-Objetivos específicos: a) estudar o código de uma implementação do Unix versão 6 para a plataforma Intel
-(xv6, desenvolvido no MIT); b) analisar e planejar a implementação de dois escalonadores de processos; c)
-implementar os escalonadores; d) avaliar os escalonadores através de experimentos; e) elaborar relatórios
-descritivos para cada um dos trabalhos.
-
-Plataforma: xv6 → http://pdos.csail.mit.edu/6.828/2012/xv6.html
-Modalidade: individual OU dupla (avaliação sempre será individual!)
-
-Descrição do Trabalho I: Implementar o escalonador de processos baseado em loteria (lottery
-scheduling). Na instanciação de um processo, deve-se passar ao sistema a quantidade de bilhetes
-que o novo processo recebe. Caso o usuário não forneça esse dado, o sistema assume um número
-default de bilhetes. Assumir também um número máximo de bilhetes que um processo pode receber.
-
-
-INSTRUÇÕES:
-
-1 - Dentro da pasta 'xv6-public' execute o comando $ 'make; make qemu-nox'
-
-2 - Aguarde o sistema iniciar a faça a chamada de sistema 'lottery'
-
-3 - Será exibido uma tabela periodicamente com as informações dos processos:
-
-    Exemplo:
-
-    PID     | NAME          | STATE         | QTD_T | OC    | PROC  | ESTI  |
-    1       | init          | sleep         | 0     |27     | 0%    | 0%    |
-    2       | sh            | sleep         | 64    |17     | 0%    | 0%    |
-    3       | lottery       | runable       | 64    |17     | 0%    | 0%    |
-    4       | lottery       | runable       | 100   |20     | 0%    | 0%    |
-    5       | lottery       | runable       | 400   |67     | 1%    | 1%    |
-    6       | lottery       | runable       | 900   |148    | 2%    | 2%    |
-    7       | lottery       | runable       | 1600  |240    | 3%    | 4%    |
-    8       | lottery       | runable       | 2500  |367    | 5%    | 6%    |
-    9       | lottery       | runable       | 3600  |573    | 9%    | 9%    |
-    10      | lottery       | runable       | 4900  |803    | 13%   | 12%   |
-    11      | lottery       | runable       | 6400  |1011   | 16%   | 16%   |
-    12      | lottery       | runable       | 8100  |1300   | 21%   | 21%   |
-    13      | lottery       | runable       | 10000 |1580   | 25%   | 25%   |
-    14      | lottery       | runable       | 1     |0      | 0%    | 0%    |
-
-    PID     = Id do processo
-    NAME    = Nome da chamada de sistema
-    STATE   = Estado do processo
-    QTD_D   = Quantidade de bilhetes que o processo recebeu
-    OC      = Quantidade de vezes que o processo ganhou a CPU
-    PROC    = Porcentagem de uso da CPU
-    ESTI    = Estimativa de uso da CPU para cada processo em % após estabilização das occorrências.
-
-
-4 - Para alterar a quantidade de processos para teste, abra o arquivo 'lottery.c'
-    e mude a macro QTD_PROC para a quantidade desejada.
-
-5 - Os processos recebem bilhetes de forma quadrática conforme instânciados.
-    Se deseja mudar isso, altera a linha 20 do arquivo lottery.c
-
-6 - Para finalizar os testes pressione ctrl-a e depois pressione x.
-
-
-
-###################################################################################
-###################################################################################
-###################################################################################
 xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
 Version 6 (v6).  xv6 loosely follows the structure and style of v6,
 but is implemented for a modern x86-based multiprocessor using ANSI C.
